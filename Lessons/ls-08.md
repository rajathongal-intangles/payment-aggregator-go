# Lesson 8: Error Handling & Retries

> **Progress**: `[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘]` 80%  
> **Time**: ~15 minutes

---

## ğŸ¯ Learning Objectives

- Understand gRPC error codes and when to use them
- Implement proper error handling in Go server
- Add retry logic with exponential backoff
- Handle Kafka consumer errors
- Implement a simple circuit breaker

---

## 1. gRPC Error Codes Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    gRPC STATUS CODES                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  CODE              VALUE   WHEN TO USE                          â”‚
â”‚  â”€â”€â”€â”€              â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚                                                                 â”‚
â”‚  OK                0       Success                              â”‚
â”‚  CANCELLED         1       Client cancelled request             â”‚
â”‚  UNKNOWN           2       Unknown error                        â”‚
â”‚  INVALID_ARGUMENT  3       Bad input from client                â”‚
â”‚  DEADLINE_EXCEEDED 4       Timeout                              â”‚
â”‚  NOT_FOUND         5       Resource doesn't exist               â”‚
â”‚  ALREADY_EXISTS    6       Resource already exists              â”‚
â”‚  PERMISSION_DENIED 7       Auth failed                          â”‚
â”‚  RESOURCE_EXHAUSTED 8      Rate limit / quota exceeded          â”‚
â”‚  FAILED_PRECONDITION 9     System not in required state         â”‚
â”‚  ABORTED           10      Conflict (retry may succeed)         â”‚
â”‚  OUT_OF_RANGE      11      Invalid range                        â”‚
â”‚  UNIMPLEMENTED     12      Method not implemented               â”‚
â”‚  INTERNAL          13      Internal server error                â”‚
â”‚  UNAVAILABLE       14      Service unavailable (retry!)         â”‚
â”‚  DATA_LOSS         15      Unrecoverable data loss              â”‚
â”‚  UNAUTHENTICATED   16      No valid credentials                 â”‚
â”‚                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RETRYABLE: UNAVAILABLE, ABORTED, RESOURCE_EXHAUSTED            â”‚
â”‚  NOT RETRYABLE: INVALID_ARGUMENT, NOT_FOUND, PERMISSION_DENIED  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Error Handling in Go Server

Create `go-service/internal/errors/errors.go`:

```go
package errors

import (
	"fmt"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// AppError represents an application-level error
type AppError struct {
	Code    codes.Code
	Message string
	Err     error // Original error
}

func (e *AppError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %v", e.Message, e.Err)
	}
	return e.Message
}

// ToGRPCError converts AppError to gRPC status error
func (e *AppError) ToGRPCError() error {
	return status.Error(e.Code, e.Message)
}

// Common error constructors

func NotFound(resource, id string) *AppError {
	return &AppError{
		Code:    codes.NotFound,
		Message: fmt.Sprintf("%s not found: %s", resource, id),
	}
}

func InvalidArgument(field, reason string) *AppError {
	return &AppError{
		Code:    codes.InvalidArgument,
		Message: fmt.Sprintf("invalid %s: %s", field, reason),
	}
}

func Internal(msg string, err error) *AppError {
	return &AppError{
		Code:    codes.Internal,
		Message: msg,
		Err:     err,
	}
}

func Unavailable(msg string) *AppError {
	return &AppError{
		Code:    codes.Unavailable,
		Message: msg,
	}
}

func AlreadyExists(resource, id string) *AppError {
	return &AppError{
		Code:    codes.AlreadyExists,
		Message: fmt.Sprintf("%s already exists: %s", resource, id),
	}
}

func ResourceExhausted(msg string) *AppError {
	return &AppError{
		Code:    codes.ResourceExhausted,
		Message: msg,
	}
}

// IsRetryable checks if an error should be retried
func IsRetryable(err error) bool {
	st, ok := status.FromError(err)
	if !ok {
		return false
	}

	switch st.Code() {
	case codes.Unavailable, codes.Aborted, codes.ResourceExhausted:
		return true
	default:
		return false
	}
}
```

---

## 3. Update gRPC Server with Better Errors

Update `go-service/internal/grpc/server.go`:

```go
package grpc

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	apperrors "github.com/yourname/payment-aggregator/go-service/internal/errors"
	pb "github.com/yourname/payment-aggregator/go-service/pb"
)

type PaymentServer struct {
	pb.UnimplementedPaymentServiceServer

	mu       sync.RWMutex
	payments map[string]*pb.Payment

	subscribersMu sync.RWMutex
	subscribers   map[chan *pb.PaymentEvent]struct{}

	// Circuit breaker state
	circuitOpen    bool
	circuitOpenAt  time.Time
	failureCount   int
	failureThreshold int
	resetTimeout   time.Duration
}

func NewPaymentServer() *PaymentServer {
	return &PaymentServer{
		payments:         make(map[string]*pb.Payment),
		subscribers:      make(map[chan *pb.PaymentEvent]struct{}),
		failureThreshold: 5,
		resetTimeout:     30 * time.Second,
	}
}

// GetPayment with proper error handling
func (s *PaymentServer) GetPayment(
	ctx context.Context,
	req *pb.GetPaymentRequest,
) (*pb.Payment, error) {
	log.Printf("[RPC] GetPayment: %s", req.PaymentId)

	// Validate input
	if req.PaymentId == "" {
		return nil, apperrors.InvalidArgument("payment_id", "cannot be empty").ToGRPCError()
	}

	// Check context deadline
	if ctx.Err() == context.DeadlineExceeded {
		return nil, status.Error(codes.DeadlineExceeded, "request timed out")
	}

	if ctx.Err() == context.Canceled {
		return nil, status.Error(codes.Canceled, "request cancelled")
	}

	// Lookup payment
	s.mu.RLock()
	payment, exists := s.payments[req.PaymentId]
	s.mu.RUnlock()

	if !exists {
		return nil, apperrors.NotFound("payment", req.PaymentId).ToGRPCError()
	}

	return payment, nil
}

// ListPayments with validation
func (s *PaymentServer) ListPayments(
	ctx context.Context,
	req *pb.ListPaymentsRequest,
) (*pb.PaymentList, error) {
	log.Printf("[RPC] ListPayments: provider=%v, status=%v, limit=%d",
		req.Provider, req.Status, req.Limit)

	// Validate limit
	limit := int(req.Limit)
	if limit < 0 {
		return nil, apperrors.InvalidArgument("limit", "cannot be negative").ToGRPCError()
	}
	if limit == 0 || limit > 100 {
		limit = 10
	}

	s.mu.RLock()
	defer s.mu.RUnlock()

	var result []*pb.Payment
	for _, p := range s.payments {
		if req.Provider != pb.Provider_PROVIDER_UNKNOWN && p.Provider != req.Provider {
			continue
		}
		if req.Status != pb.PaymentStatus_STATUS_UNKNOWN && p.Status != req.Status {
			continue
		}

		result = append(result, p)
		if len(result) >= limit {
			break
		}
	}

	return &pb.PaymentList{
		Payments:   result,
		TotalCount: int32(len(result)),
	}, nil
}

// StreamPayments with error recovery
func (s *PaymentServer) StreamPayments(
	req *pb.ListPaymentsRequest,
	stream pb.PaymentService_StreamPaymentsServer,
) error {
	log.Printf("[RPC] StreamPayments started")

	ch := s.subscribe()
	defer s.unsubscribe(ch)

	// Send existing payments
	s.mu.RLock()
	for _, p := range s.payments {
		if req.Provider != pb.Provider_PROVIDER_UNKNOWN && p.Provider != req.Provider {
			continue
		}

		event := &pb.PaymentEvent{Payment: p, EventType: "existing"}
		if err := stream.Send(event); err != nil {
			s.mu.RUnlock()
			log.Printf("[RPC] StreamPayments send error: %v", err)
			return status.Errorf(codes.Internal, "failed to send: %v", err)
		}
	}
	s.mu.RUnlock()

	// Stream new payments
	for {
		select {
		case <-stream.Context().Done():
			err := stream.Context().Err()
			if err == context.Canceled {
				log.Println("[RPC] StreamPayments: client disconnected")
				return nil
			}
			if err == context.DeadlineExceeded {
				return status.Error(codes.DeadlineExceeded, "stream deadline exceeded")
			}
			return nil

		case event, ok := <-ch:
			if !ok {
				return status.Error(codes.Unavailable, "stream closed")
			}

			if req.Provider != pb.Provider_PROVIDER_UNKNOWN &&
				event.Payment.Provider != req.Provider {
				continue
			}

			if err := stream.Send(event); err != nil {
				log.Printf("[RPC] StreamPayments send error: %v", err)
				return status.Errorf(codes.Internal, "send failed: %v", err)
			}
		}
	}
}

// AddPayment with validation
func (s *PaymentServer) AddPayment(p *pb.Payment) error {
	if p == nil {
		return apperrors.InvalidArgument("payment", "cannot be nil")
	}
	if p.Id == "" {
		return apperrors.InvalidArgument("payment.id", "cannot be empty")
	}

	s.mu.Lock()
	s.payments[p.Id] = p
	s.mu.Unlock()

	log.Printf("[STORE] Added: %s", p.Id)

	event := &pb.PaymentEvent{Payment: p, EventType: "new"}
	s.broadcast(event)

	return nil
}

func (s *PaymentServer) broadcast(event *pb.PaymentEvent) {
	s.subscribersMu.RLock()
	defer s.subscribersMu.RUnlock()

	for ch := range s.subscribers {
		select {
		case ch <- event:
		default:
			log.Printf("[BROADCAST] Subscriber slow, skipping")
		}
	}
}

func (s *PaymentServer) subscribe() chan *pb.PaymentEvent {
	ch := make(chan *pb.PaymentEvent, 10)
	s.subscribersMu.Lock()
	s.subscribers[ch] = struct{}{}
	s.subscribersMu.Unlock()
	log.Printf("[SUBSCRIBE] New subscriber (total: %d)", len(s.subscribers))
	return ch
}

func (s *PaymentServer) unsubscribe(ch chan *pb.PaymentEvent) {
	s.subscribersMu.Lock()
	delete(s.subscribers, ch)
	close(ch)
	s.subscribersMu.Unlock()
	log.Printf("[UNSUBSCRIBE] Subscriber left (total: %d)", len(s.subscribers))
}

func (s *PaymentServer) SeedTestData() {
	testPayments := []*pb.Payment{
		{
			Id:            "pay_001",
			Provider:      pb.Provider_PROVIDER_STRIPE,
			Amount:        99.99,
			Currency:      "USD",
			Status:        pb.PaymentStatus_STATUS_COMPLETED,
			CustomerEmail: "alice@example.com",
			CreatedAt:     time.Now().Unix(),
			ProcessedAt:   time.Now().Unix(),
			Metadata:      map[string]string{"order_id": "ORD-001"},
		},
		{
			Id:            "pay_002",
			Provider:      pb.Provider_PROVIDER_RAZORPAY,
			Amount:        1500.00,
			Currency:      "INR",
			Status:        pb.PaymentStatus_STATUS_PENDING,
			CustomerEmail: "bob@example.com",
			CreatedAt:     time.Now().Unix(),
			Metadata:      map[string]string{"order_id": "ORD-002"},
		},
		{
			Id:            "pay_003",
			Provider:      pb.Provider_PROVIDER_PAYPAL,
			Amount:        250.00,
			Currency:      "EUR",
			Status:        pb.PaymentStatus_STATUS_COMPLETED,
			CustomerEmail: "carol@example.com",
			CreatedAt:     time.Now().Unix(),
			ProcessedAt:   time.Now().Unix(),
			Metadata:      map[string]string{"order_id": "ORD-003"},
		},
	}

	for _, p := range testPayments {
		s.AddPayment(p)
	}

	fmt.Printf("âœ… Seeded %d test payments\n", len(testPayments))
}
```

---

## 4. Retry with Exponential Backoff

Create `go-service/internal/retry/retry.go`:

```go
package retry

import (
	"context"
	"math"
	"math/rand"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// Config holds retry configuration
type Config struct {
	MaxRetries     int
	InitialBackoff time.Duration
	MaxBackoff     time.Duration
	BackoffFactor  float64
	Jitter         bool
}

// DefaultConfig returns sensible defaults
func DefaultConfig() Config {
	return Config{
		MaxRetries:     3,
		InitialBackoff: 100 * time.Millisecond,
		MaxBackoff:     10 * time.Second,
		BackoffFactor:  2.0,
		Jitter:         true,
	}
}

// Do executes fn with retries
func Do(ctx context.Context, cfg Config, fn func() error) error {
	var lastErr error

	for attempt := 0; attempt <= cfg.MaxRetries; attempt++ {
		// Check context before attempt
		if ctx.Err() != nil {
			return ctx.Err()
		}

		// Execute function
		err := fn()
		if err == nil {
			return nil
		}

		lastErr = err

		// Check if error is retryable
		if !isRetryable(err) {
			return err
		}

		// Don't sleep after last attempt
		if attempt == cfg.MaxRetries {
			break
		}

		// Calculate backoff
		backoff := calculateBackoff(attempt, cfg)

		// Wait or context cancel
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(backoff):
			// Continue to next attempt
		}
	}

	return lastErr
}

func calculateBackoff(attempt int, cfg Config) time.Duration {
	backoff := float64(cfg.InitialBackoff) * math.Pow(cfg.BackoffFactor, float64(attempt))
	
	if backoff > float64(cfg.MaxBackoff) {
		backoff = float64(cfg.MaxBackoff)
	}

	if cfg.Jitter {
		// Add Â±25% jitter
		jitter := backoff * 0.25 * (rand.Float64()*2 - 1)
		backoff += jitter
	}

	return time.Duration(backoff)
}

func isRetryable(err error) bool {
	st, ok := status.FromError(err)
	if !ok {
		return false
	}

	switch st.Code() {
	case codes.Unavailable, codes.Aborted, codes.ResourceExhausted, codes.DeadlineExceeded:
		return true
	default:
		return false
	}
}
```

### Using Retry in Node.js Client

Update `node-service/src/retry.ts`:

```typescript
export interface RetryConfig {
  maxRetries: number;
  initialBackoffMs: number;
  maxBackoffMs: number;
  backoffFactor: number;
  jitter: boolean;
}

export const defaultRetryConfig: RetryConfig = {
  maxRetries: 3,
  initialBackoffMs: 100,
  maxBackoffMs: 10000,
  backoffFactor: 2,
  jitter: true,
};

export async function withRetry<T>(
  fn: () => Promise<T>,
  config: RetryConfig = defaultRetryConfig
): Promise<T> {
  let lastError: Error | undefined;

  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (err) {
      lastError = err as Error;

      if (!isRetryable(err)) {
        throw err;
      }

      if (attempt === config.maxRetries) {
        break;
      }

      const backoff = calculateBackoff(attempt, config);
      console.log(`ğŸ”„ Retry attempt ${attempt + 1}/${config.maxRetries} in ${backoff}ms...`);
      await sleep(backoff);
    }
  }

  throw lastError;
}

function calculateBackoff(attempt: number, config: RetryConfig): number {
  let backoff = config.initialBackoffMs * Math.pow(config.backoffFactor, attempt);
  backoff = Math.min(backoff, config.maxBackoffMs);

  if (config.jitter) {
    const jitter = backoff * 0.25 * (Math.random() * 2 - 1);
    backoff += jitter;
  }

  return Math.floor(backoff);
}

function isRetryable(err: any): boolean {
  const retryableCodes = [14, 10, 8, 4]; // UNAVAILABLE, ABORTED, RESOURCE_EXHAUSTED, DEADLINE_EXCEEDED
  return retryableCodes.includes(err?.code);
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

---

## 5. Circuit Breaker Pattern

Create `go-service/internal/circuit/breaker.go`:

```go
package circuit

import (
	"errors"
	"sync"
	"time"
)

var ErrCircuitOpen = errors.New("circuit breaker is open")

type State int

const (
	StateClosed State = iota
	StateOpen
	StateHalfOpen
)

func (s State) String() string {
	switch s {
	case StateClosed:
		return "CLOSED"
	case StateOpen:
		return "OPEN"
	case StateHalfOpen:
		return "HALF-OPEN"
	default:
		return "UNKNOWN"
	}
}

type Breaker struct {
	mu sync.RWMutex

	state            State
	failureCount     int
	successCount     int
	failureThreshold int
	successThreshold int
	timeout          time.Duration
	lastFailure      time.Time

	onStateChange func(from, to State)
}

type Config struct {
	FailureThreshold int           // Failures before opening
	SuccessThreshold int           // Successes in half-open before closing
	Timeout          time.Duration // Time before trying again
	OnStateChange    func(from, to State)
}

func NewBreaker(cfg Config) *Breaker {
	if cfg.FailureThreshold == 0 {
		cfg.FailureThreshold = 5
	}
	if cfg.SuccessThreshold == 0 {
		cfg.SuccessThreshold = 2
	}
	if cfg.Timeout == 0 {
		cfg.Timeout = 30 * time.Second
	}

	return &Breaker{
		state:            StateClosed,
		failureThreshold: cfg.FailureThreshold,
		successThreshold: cfg.SuccessThreshold,
		timeout:          cfg.Timeout,
		onStateChange:    cfg.OnStateChange,
	}
}

// Execute runs fn if circuit allows
func (b *Breaker) Execute(fn func() error) error {
	if !b.Allow() {
		return ErrCircuitOpen
	}

	err := fn()

	if err != nil {
		b.RecordFailure()
	} else {
		b.RecordSuccess()
	}

	return err
}

// Allow checks if request should be allowed
func (b *Breaker) Allow() bool {
	b.mu.RLock()
	state := b.state
	lastFailure := b.lastFailure
	b.mu.RUnlock()

	switch state {
	case StateClosed:
		return true
	case StateOpen:
		// Check if timeout has passed
		if time.Since(lastFailure) > b.timeout {
			b.toHalfOpen()
			return true
		}
		return false
	case StateHalfOpen:
		return true
	default:
		return false
	}
}

// RecordSuccess records a successful call
func (b *Breaker) RecordSuccess() {
	b.mu.Lock()
	defer b.mu.Unlock()

	switch b.state {
	case StateClosed:
		b.failureCount = 0
	case StateHalfOpen:
		b.successCount++
		if b.successCount >= b.successThreshold {
			b.setState(StateClosed)
			b.failureCount = 0
			b.successCount = 0
		}
	}
}

// RecordFailure records a failed call
func (b *Breaker) RecordFailure() {
	b.mu.Lock()
	defer b.mu.Unlock()

	b.failureCount++
	b.lastFailure = time.Now()

	switch b.state {
	case StateClosed:
		if b.failureCount >= b.failureThreshold {
			b.setState(StateOpen)
		}
	case StateHalfOpen:
		b.setState(StateOpen)
		b.successCount = 0
	}
}

func (b *Breaker) toHalfOpen() {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.setState(StateHalfOpen)
	b.successCount = 0
}

func (b *Breaker) setState(new State) {
	old := b.state
	b.state = new
	if b.onStateChange != nil && old != new {
		go b.onStateChange(old, new)
	}
}

// State returns current state
func (b *Breaker) State() State {
	b.mu.RLock()
	defer b.mu.RUnlock()
	return b.state
}
```

### Using Circuit Breaker

```go
// In Kafka consumer
breaker := circuit.NewBreaker(circuit.Config{
    FailureThreshold: 5,
    SuccessThreshold: 2,
    Timeout:          30 * time.Second,
    OnStateChange: func(from, to circuit.State) {
        log.Printf("[CIRCUIT] State changed: %s â†’ %s", from, to)
    },
})

// Wrap processing with circuit breaker
err := breaker.Execute(func() error {
    return processPayment(payment)
})

if err == circuit.ErrCircuitOpen {
    log.Println("[CIRCUIT] Circuit open, skipping payment")
    // Maybe send to dead letter queue
}
```

---

## 6. Kafka Error Handling & Dead Letter Queue

Update `go-service/internal/kafka/consumer.go`:

```go
package kafka

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/confluentinc/confluent-kafka-go/v2/kafka"

	"github.com/yourname/payment-aggregator/go-service/internal/circuit"
	"github.com/yourname/payment-aggregator/go-service/internal/config"
	pb "github.com/yourname/payment-aggregator/go-service/pb"
)

type PaymentHandler func(*pb.Payment) error

type Consumer struct {
	consumer    *kafka.Consumer
	dlqProducer *kafka.Producer // Dead Letter Queue producer
	topic       string
	dlqTopic    string
	handler     PaymentHandler
	breaker     *circuit.Breaker
}

// FailedMessage represents a message that couldn't be processed
type FailedMessage struct {
	OriginalTopic string            `json:"original_topic"`
	Partition     int32             `json:"partition"`
	Offset        int64             `json:"offset"`
	Key           string            `json:"key"`
	Value         string            `json:"value"`
	Error         string            `json:"error"`
	Timestamp     int64             `json:"timestamp"`
	RetryCount    int               `json:"retry_count"`
}

func NewConsumer(cfg *config.Config, handler PaymentHandler) (*Consumer, error) {
	configMap := &kafka.ConfigMap{
		"bootstrap.servers":  cfg.KafkaBrokers,
		"group.id":           cfg.KafkaGroupID,
		"auto.offset.reset":  "earliest",
		"enable.auto.commit": false, // Manual commit for better control
	}

	if cfg.KafkaSSL {
		configMap.SetKey("security.protocol", "SASL_SSL")
	}
	if cfg.HasSASL() {
		configMap.SetKey("sasl.mechanisms", cfg.KafkaSASLMechanism)
		configMap.SetKey("sasl.username", cfg.KafkaSASLUsername)
		configMap.SetKey("sasl.password", cfg.KafkaSASLPassword)
	}

	consumer, err := kafka.NewConsumer(configMap)
	if err != nil {
		return nil, fmt.Errorf("failed to create consumer: %w", err)
	}

	// Create DLQ producer with same config
	dlqProducer, err := kafka.NewProducer(configMap)
	if err != nil {
		consumer.Close()
		return nil, fmt.Errorf("failed to create DLQ producer: %w", err)
	}

	breaker := circuit.NewBreaker(circuit.Config{
		FailureThreshold: 5,
		SuccessThreshold: 2,
		Timeout:          30 * time.Second,
		OnStateChange: func(from, to circuit.State) {
			log.Printf("[CIRCUIT] %s â†’ %s", from, to)
		},
	})

	return &Consumer{
		consumer:    consumer,
		dlqProducer: dlqProducer,
		topic:       cfg.KafkaTopic,
		dlqTopic:    cfg.KafkaTopic + ".dlq",
		handler:     handler,
		breaker:     breaker,
	}, nil
}

func (c *Consumer) Start(ctx context.Context) error {
	if err := c.consumer.Subscribe(c.topic, nil); err != nil {
		return fmt.Errorf("subscribe failed: %w", err)
	}

	log.Printf("[CONSUMER] ğŸ“¡ Subscribed to: %s", c.topic)
	log.Printf("[CONSUMER] ğŸ“­ DLQ topic: %s", c.dlqTopic)

	for {
		select {
		case <-ctx.Done():
			return nil
		default:
			msg, err := c.consumer.ReadMessage(100 * time.Millisecond)
			if err != nil {
				if kafkaErr, ok := err.(kafka.Error); ok {
					if kafkaErr.Code() == kafka.ErrTimedOut {
						continue
					}
				}
				log.Printf("[CONSUMER] âŒ Read error: %v", err)
				continue
			}

			c.processWithRetry(msg)
		}
	}
}

func (c *Consumer) processWithRetry(msg *kafka.Message) {
	maxRetries := 3

	for attempt := 0; attempt <= maxRetries; attempt++ {
		err := c.breaker.Execute(func() error {
			return c.processMessage(msg)
		})

		if err == nil {
			// Success - commit offset
			c.consumer.CommitMessage(msg)
			return
		}

		if err == circuit.ErrCircuitOpen {
			log.Printf("[CONSUMER] âš¡ Circuit open, sending to DLQ")
			c.sendToDLQ(msg, "circuit_breaker_open", 0)
			c.consumer.CommitMessage(msg)
			return
		}

		if attempt < maxRetries {
			backoff := time.Duration(100*(1<<attempt)) * time.Millisecond
			log.Printf("[CONSUMER] ğŸ”„ Retry %d/%d in %v", attempt+1, maxRetries, backoff)
			time.Sleep(backoff)
		}
	}

	// All retries failed - send to DLQ
	log.Printf("[CONSUMER] âŒ Max retries exceeded, sending to DLQ")
	c.sendToDLQ(msg, "max_retries_exceeded", maxRetries)
	c.consumer.CommitMessage(msg)
}

func (c *Consumer) processMessage(msg *kafka.Message) error {
	raw, err := ParseMessage(msg.Value)
	if err != nil {
		return fmt.Errorf("parse error: %w", err)
	}

	payment := raw.ToProto()
	
	if err := c.handler(payment); err != nil {
		return fmt.Errorf("handler error: %w", err)
	}

	log.Printf("[CONSUMER] âœ… %s | %s | %.2f %s",
		payment.Id, payment.Provider, payment.Amount, payment.Currency)

	return nil
}

func (c *Consumer) sendToDLQ(msg *kafka.Message, reason string, retryCount int) {
	failed := FailedMessage{
		OriginalTopic: c.topic,
		Partition:     msg.TopicPartition.Partition,
		Offset:        int64(msg.TopicPartition.Offset),
		Key:           string(msg.Key),
		Value:         string(msg.Value),
		Error:         reason,
		Timestamp:     time.Now().Unix(),
		RetryCount:    retryCount,
	}

	data, _ := json.Marshal(failed)

	err := c.dlqProducer.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{
			Topic:     &c.dlqTopic,
			Partition: kafka.PartitionAny,
		},
		Key:   msg.Key,
		Value: data,
	}, nil)

	if err != nil {
		log.Printf("[DLQ] âŒ Failed to send to DLQ: %v", err)
	} else {
		log.Printf("[DLQ] ğŸ“¤ Sent to DLQ: %s", string(msg.Key))
	}
}

func (c *Consumer) Close() error {
	c.dlqProducer.Close()
	return c.consumer.Close()
}
```

---

## 7. Error Handling Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ERROR HANDLING FLOW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Message arrives                                                â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚  â”‚ Circuit OK? â”‚â”€â”€Noâ”€â”€â–¶ Send to DLQ                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚        â”‚Yes                                                     â”‚
â”‚        â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚  â”‚  Process    â”‚                                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚        â”‚                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                                   â”‚
â”‚   â”‚         â”‚                                                   â”‚
â”‚ Success   Error                                                 â”‚
â”‚   â”‚         â”‚                                                   â”‚
â”‚   â–¼         â–¼                                                   â”‚
â”‚ Commit   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚ Offset   â”‚ Retryable?  â”‚                                        â”‚
â”‚          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚           â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                           â”‚
â”‚           â”‚         â”‚                                           â”‚
â”‚          Yes        No                                          â”‚
â”‚           â”‚         â”‚                                           â”‚
â”‚           â–¼         â–¼                                           â”‚
â”‚        Retry     Send to DLQ                                    â”‚
â”‚      (backoff)                                                  â”‚
â”‚           â”‚                                                     â”‚
â”‚           â–¼                                                     â”‚
â”‚  Max retries? â”€â”€Yesâ”€â”€â–¶ Send to DLQ                              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 8. Node.js Error Handling

Update error handling in `node-service/src/client.ts`:

```typescript
// Add to existing client.ts

import * as grpc from '@grpc/grpc-js';

// Error classification
export function classifyError(err: any): {
  retryable: boolean;
  code: number;
  message: string;
} {
  const code = err?.code ?? grpc.status.UNKNOWN;
  const message = err?.message ?? 'Unknown error';

  const retryableCodes = [
    grpc.status.UNAVAILABLE,
    grpc.status.ABORTED,
    grpc.status.RESOURCE_EXHAUSTED,
    grpc.status.DEADLINE_EXCEEDED,
  ];

  return {
    retryable: retryableCodes.includes(code),
    code,
    message,
  };
}

// Error names for logging
export function getErrorName(code: number): string {
  const names: Record<number, string> = {
    0: 'OK',
    1: 'CANCELLED',
    2: 'UNKNOWN',
    3: 'INVALID_ARGUMENT',
    4: 'DEADLINE_EXCEEDED',
    5: 'NOT_FOUND',
    6: 'ALREADY_EXISTS',
    7: 'PERMISSION_DENIED',
    8: 'RESOURCE_EXHAUSTED',
    9: 'FAILED_PRECONDITION',
    10: 'ABORTED',
    11: 'OUT_OF_RANGE',
    12: 'UNIMPLEMENTED',
    13: 'INTERNAL',
    14: 'UNAVAILABLE',
    15: 'DATA_LOSS',
    16: 'UNAUTHENTICATED',
  };
  return names[code] ?? 'UNKNOWN';
}
```

---

## âœ… Lesson 8 Checklist

- [ ] Understand gRPC error codes
- [ ] Know which errors are retryable
- [ ] Created `internal/errors/errors.go`
- [ ] Created `internal/retry/retry.go`
- [ ] Created `internal/circuit/breaker.go`
- [ ] Updated Kafka consumer with error handling
- [ ] Understand Dead Letter Queue pattern
- [ ] Know how circuit breaker prevents cascading failures

---

## ğŸ”œ Next: Lesson 9 - Testing & Debugging

- Unit testing gRPC services
- Integration testing
- Using grpcurl for debugging
- Logging best practices

---

**Type `next` to continue or ask questions!**

**Common questions:**
- "How do I process messages from the DLQ?"
- "What's the difference between circuit breaker and retry?"
- "How do I add metrics for monitoring?"