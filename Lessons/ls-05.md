# Lesson 5: Kafka Consumer & Producer in Go

> **Progress**: `[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë]` 50%  
> **Time**: ~20 minutes

---

## üéØ Learning Objectives

- Understand Kafka basics (topics, partitions, consumer groups)
- Connect to Kafka with SASL/SSL authentication
- Build a producer to generate test payment data
- Build a consumer that pushes to Node.js ONE message at a time

---

## 1. Architecture: One Message at a Time

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    REAL-TIME STREAMING FLOW                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  Producer        Kafka           Go Server           Node.js    ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ           ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ           ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  pay_001 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ [topic] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ AddPayment()                   ‚îÇ
‚îÇ                                      ‚îÇ                          ‚îÇ
‚îÇ                                      ‚ñº                          ‚îÇ
‚îÇ                                 broadcast() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ log(pay_001)
‚îÇ                                                                 ‚îÇ
‚îÇ  pay_002 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ [topic] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ AddPayment()                   ‚îÇ
‚îÇ                                      ‚îÇ                          ‚îÇ
‚îÇ                                      ‚ñº                          ‚îÇ
‚îÇ                                 broadcast() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ log(pay_002)
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ  Each Kafka message is pushed to Node.js IMMEDIATELY    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  via gRPC server streaming - NO BATCHING!               ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 2. Kafka Quick Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         KAFKA BASICS                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  TOPIC: payments.raw                                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ Partition 0: [msg1] [msg2] [msg3] [msg4] ‚îÄ‚îÄ‚îÄ‚ñ∂           ‚îÇ    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îÇ
‚îÇ  ‚îÇ Partition 1: [msg5] [msg6] [msg7] ‚îÄ‚îÄ‚îÄ‚ñ∂                  ‚îÇ    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îÇ
‚îÇ  ‚îÇ Partition 2: [msg8] [msg9] ‚îÄ‚îÄ‚îÄ‚ñ∂                         ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚Ä¢ Messages are ordered WITHIN a partition                      ‚îÇ
‚îÇ  ‚Ä¢ Partitions enable parallel consumption                       ‚îÇ
‚îÇ  ‚Ä¢ Consumer Group: multiple consumers share the load            ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 3. Project Structure

```
go-service/
‚îú‚îÄ‚îÄ .env                       # ‚Üê Your Kafka credentials
‚îú‚îÄ‚îÄ .env.example               # ‚Üê Template
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îú‚îÄ‚îÄ producer/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go            # Test data generator
‚îÇ   ‚îî‚îÄ‚îÄ server/
‚îÇ       ‚îî‚îÄ‚îÄ main.go            # Consumer + gRPC server
‚îî‚îÄ‚îÄ internal/
    ‚îú‚îÄ‚îÄ config/
    ‚îÇ   ‚îî‚îÄ‚îÄ config.go          # Environment loader
    ‚îú‚îÄ‚îÄ grpc/
    ‚îÇ   ‚îî‚îÄ‚îÄ server.go          # gRPC with broadcast
    ‚îî‚îÄ‚îÄ kafka/
        ‚îú‚îÄ‚îÄ message.go         # JSON ‚Üí Protobuf
        ‚îú‚îÄ‚îÄ producer.go        # Kafka producer
        ‚îî‚îÄ‚îÄ consumer.go        # Kafka consumer
```

---

## 4. Environment Configuration

Create `go-service/.env`:

```env
# Kafka Configuration
KAFKA_BROKERS=your-broker-url:9092
KAFKA_SSL=true
KAFKA_TOPIC=payments.raw
KAFKA_GROUP_ID=payment-service

# SASL Authentication
KAFKA_SASL_MECHANISM=PLAIN
KAFKA_SASL_USERNAME=your-username
KAFKA_SASL_PASSWORD=your-password

# Schema Registry (optional)
KAFKA_SCHEMA_REGISTRY_URL=https://your-schema-registry-url
KAFKA_SCHEMA_REGISTRY_AUTH=your-api-key:your-api-secret

# gRPC Configuration
GRPC_PORT=50051
```

---

## 5. Config Loader

`go-service/internal/config/config.go`:

```go
package config

import (
	"os"
	"strings"
)

type Config struct {
	// Kafka
	KafkaBrokers       string
	KafkaSSL           bool
	KafkaSASLMechanism string
	KafkaSASLUsername  string
	KafkaSASLPassword  string
	KafkaTopic         string
	KafkaGroupID       string

	// Schema Registry (optional)
	SchemaRegistryURL  string
	SchemaRegistryAuth string

	// gRPC
	GRPCPort string
}

func Load() *Config {
	return &Config{
		KafkaBrokers:       getEnv("KAFKA_BROKERS", "localhost:9092"),
		KafkaSSL:           getEnv("KAFKA_SSL", "false") == "true",
		KafkaSASLMechanism: getEnv("KAFKA_SASL_MECHANISM", "PLAIN"),
		KafkaSASLUsername:  getEnv("KAFKA_SASL_USERNAME", ""),
		KafkaSASLPassword:  getEnv("KAFKA_SASL_PASSWORD", ""),
		KafkaTopic:         getEnv("KAFKA_TOPIC", "payments.raw"),
		KafkaGroupID:       getEnv("KAFKA_GROUP_ID", "payment-service"),
		SchemaRegistryURL:  getEnv("KAFKA_SCHEMA_REGISTRY_URL", ""),
		SchemaRegistryAuth: getEnv("KAFKA_SCHEMA_REGISTRY_AUTH", ""),
		GRPCPort:           getEnv("GRPC_PORT", "50051"),
	}
}

func getEnv(key, fallback string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return fallback
}

// HasSASL checks if SASL authentication is configured
func (c *Config) HasSASL() bool {
	return c.KafkaSASLUsername != "" && c.KafkaSASLPassword != ""
}
```

---

## 6. Kafka Message Format

Raw JSON from Kafka:

```json
{
  "id": "pay_abc123",
  "provider": "stripe",
  "amount": 5000,
  "currency": "usd",
  "status": "succeeded",
  "customer_email": "user@example.com",
  "metadata": { "order_id": "ORD-123" },
  "timestamp": 1703001234
}
```

`go-service/internal/kafka/message.go`:

```go
package kafka

import (
	"encoding/json"
	"strings"
	"time"

	pb "github.com/yourname/payment-aggregator/go-service/pb"
)

// RawPayment represents the JSON message from Kafka
type RawPayment struct {
	ID            string            `json:"id"`
	Provider      string            `json:"provider"`
	Amount        float64           `json:"amount"`
	Currency      string            `json:"currency"`
	Status        string            `json:"status"`
	CustomerEmail string            `json:"customer_email"`
	Metadata      map[string]string `json:"metadata"`
	Timestamp     int64             `json:"timestamp"`
}

// ToProto converts raw payment to protobuf Payment
func (r *RawPayment) ToProto() *pb.Payment {
	return &pb.Payment{
		Id:            r.ID,
		Provider:      mapProvider(r.Provider),
		Amount:        normalizeAmount(r.Amount, r.Currency),
		Currency:      strings.ToUpper(r.Currency),
		Status:        mapStatus(r.Status),
		CustomerEmail: r.CustomerEmail,
		Metadata:      r.Metadata,
		CreatedAt:     r.Timestamp,
		ProcessedAt:   time.Now().Unix(),
	}
}

// ParseMessage parses JSON bytes into RawPayment
func ParseMessage(data []byte) (*RawPayment, error) {
	var raw RawPayment
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}
	return &raw, nil
}

func mapProvider(provider string) pb.Provider {
	switch strings.ToLower(provider) {
	case "stripe":
		return pb.Provider_PROVIDER_STRIPE
	case "razorpay":
		return pb.Provider_PROVIDER_RAZORPAY
	case "paypal":
		return pb.Provider_PROVIDER_PAYPAL
	default:
		return pb.Provider_PROVIDER_UNKNOWN
	}
}

func mapStatus(status string) pb.PaymentStatus {
	switch strings.ToLower(status) {
	case "pending", "processing":
		return pb.PaymentStatus_STATUS_PENDING
	case "succeeded", "completed", "paid":
		return pb.PaymentStatus_STATUS_COMPLETED
	case "failed", "declined":
		return pb.PaymentStatus_STATUS_FAILED
	case "refunded":
		return pb.PaymentStatus_STATUS_REFUNDED
	default:
		return pb.PaymentStatus_STATUS_UNKNOWN
	}
}

// normalizeAmount converts cents to dollars for USD/EUR
func normalizeAmount(amount float64, currency string) float64 {
	currency = strings.ToLower(currency)
	if currency == "usd" || currency == "eur" || currency == "gbp" {
		if amount >= 100 {
			return amount / 100
		}
	}
	return amount
}
```

---

## 7. Kafka Producer

`go-service/internal/kafka/producer.go`:

```go
package kafka

import (
	"encoding/json"
	"fmt"
	"log"

	"github.com/confluentinc/confluent-kafka-go/v2/kafka"
	"github.com/yourname/payment-aggregator/go-service/internal/config"
)

type Producer struct {
	producer *kafka.Producer
	topic    string
}

// NewProducer creates a Kafka producer from config
func NewProducer(cfg *config.Config) (*Producer, error) {
	configMap := &kafka.ConfigMap{
		"bootstrap.servers": cfg.KafkaBrokers,
		"acks":              "all",
	}

	// Add SSL if enabled
	if cfg.KafkaSSL {
		configMap.SetKey("security.protocol", "SASL_SSL")
	}

	// Add SASL authentication if configured
	if cfg.HasSASL() {
		if !cfg.KafkaSSL {
			configMap.SetKey("security.protocol", "SASL_PLAINTEXT")
		}
		configMap.SetKey("sasl.mechanisms", cfg.KafkaSASLMechanism)
		configMap.SetKey("sasl.username", cfg.KafkaSASLUsername)
		configMap.SetKey("sasl.password", cfg.KafkaSASLPassword)
	}

	producer, err := kafka.NewProducer(configMap)
	if err != nil {
		return nil, fmt.Errorf("failed to create producer: %w", err)
	}

	// Handle delivery reports in background
	go func() {
		for e := range producer.Events() {
			switch ev := e.(type) {
			case *kafka.Message:
				if ev.TopicPartition.Error != nil {
					log.Printf("[PRODUCER] ‚ùå Delivery failed: %v", ev.TopicPartition.Error)
				} else {
					log.Printf("[PRODUCER] ‚úÖ Delivered: %s [partition %d]",
						string(ev.Key), ev.TopicPartition.Partition)
				}
			}
		}
	}()

	return &Producer{producer: producer, topic: cfg.KafkaTopic}, nil
}

// SendPayment sends a payment message to Kafka
func (p *Producer) SendPayment(payment *RawPayment) error {
	data, err := json.Marshal(payment)
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}

	return p.producer.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{
			Topic:     &p.topic,
			Partition: kafka.PartitionAny,
		},
		Key:   []byte(payment.ID),
		Value: data,
	}, nil)
}

func (p *Producer) Flush(timeoutMs int) { p.producer.Flush(timeoutMs) }
func (p *Producer) Close()              { p.producer.Close() }
```

---

## 8. Kafka Consumer

`go-service/internal/kafka/consumer.go`:

```go
package kafka

import (
	"context"
	"fmt"
	"log"

	"github.com/confluentinc/confluent-kafka-go/v2/kafka"
	"github.com/yourname/payment-aggregator/go-service/internal/config"
	pb "github.com/yourname/payment-aggregator/go-service/pb"
)

// PaymentHandler is called for each consumed payment
type PaymentHandler func(*pb.Payment)

type Consumer struct {
	consumer *kafka.Consumer
	topic    string
	handler  PaymentHandler
}

// NewConsumer creates a Kafka consumer from config
func NewConsumer(cfg *config.Config, handler PaymentHandler) (*Consumer, error) {
	configMap := &kafka.ConfigMap{
		"bootstrap.servers":  cfg.KafkaBrokers,
		"group.id":           cfg.KafkaGroupID,
		"auto.offset.reset":  "earliest",
		"enable.auto.commit": true,
	}

	if cfg.KafkaSSL {
		configMap.SetKey("security.protocol", "SASL_SSL")
	}

	if cfg.HasSASL() {
		if !cfg.KafkaSSL {
			configMap.SetKey("security.protocol", "SASL_PLAINTEXT")
		}
		configMap.SetKey("sasl.mechanisms", cfg.KafkaSASLMechanism)
		configMap.SetKey("sasl.username", cfg.KafkaSASLUsername)
		configMap.SetKey("sasl.password", cfg.KafkaSASLPassword)
	}

	consumer, err := kafka.NewConsumer(configMap)
	if err != nil {
		return nil, fmt.Errorf("failed to create consumer: %w", err)
	}

	return &Consumer{consumer: consumer, topic: cfg.KafkaTopic, handler: handler}, nil
}

// Start begins consuming messages (blocking)
func (c *Consumer) Start(ctx context.Context) error {
	if err := c.consumer.Subscribe(c.topic, nil); err != nil {
		return fmt.Errorf("failed to subscribe: %w", err)
	}

	log.Printf("[CONSUMER] üì° Subscribed to: %s", c.topic)

	for {
		select {
		case <-ctx.Done():
			return nil
		default:
			msg, err := c.consumer.ReadMessage(-1)
			if err != nil {
				continue
			}
			c.processMessage(msg)
		}
	}
}

func (c *Consumer) processMessage(msg *kafka.Message) {
	raw, err := ParseMessage(msg.Value)
	if err != nil {
		log.Printf("[CONSUMER] ‚ùå Parse error: %v", err)
		return
	}

	payment := raw.ToProto()
	log.Printf("[CONSUMER] ‚úÖ %s | %s | %.2f %s",
		payment.Id, payment.Provider, payment.Amount, payment.Currency)

	// This triggers broadcast to all streaming Node.js clients!
	c.handler(payment)
}

func (c *Consumer) Close() error { return c.consumer.Close() }
```

---

## 9. gRPC Server with Real-Time Broadcast

The key change: `AddPayment()` now broadcasts to ALL connected streaming clients!

`go-service/internal/grpc/server.go` (key parts):

```go
type PaymentServer struct {
	pb.UnimplementedPaymentServiceServer
	
	mu          sync.RWMutex
	payments    map[string]*pb.Payment
	
	// Real-time streaming subscribers
	subscribersMu sync.RWMutex
	subscribers   map[chan *pb.PaymentEvent]struct{}
}

// AddPayment stores AND broadcasts to streaming clients
func (s *PaymentServer) AddPayment(p *pb.Payment) {
	s.mu.Lock()
	s.payments[p.Id] = p
	s.mu.Unlock()

	// Broadcast to ALL connected Node.js clients!
	event := &pb.PaymentEvent{Payment: p, EventType: "new"}
	s.broadcast(event)
}

func (s *PaymentServer) broadcast(event *pb.PaymentEvent) {
	s.subscribersMu.RLock()
	defer s.subscribersMu.RUnlock()

	for ch := range s.subscribers {
		select {
		case ch <- event:  // Send to subscriber
		default:           // Skip if slow
		}
	}
}

// StreamPayments - Node.js calls this to receive real-time updates
func (s *PaymentServer) StreamPayments(req, stream) error {
	ch := s.subscribe()
	defer s.unsubscribe(ch)

	// Send existing payments first
	for _, p := range s.payments {
		stream.Send(&pb.PaymentEvent{Payment: p, EventType: "existing"})
	}

	// Then wait for NEW payments (one at a time!)
	for event := range ch {
		stream.Send(event)  // Pushed immediately!
	}
}
```

---

## 10. Producer CLI

`go-service/cmd/producer/main.go`:

```go
package main

import (
	"flag"
	"log"
	"time"

	"github.com/joho/godotenv"
	"github.com/yourname/payment-aggregator/go-service/internal/config"
	"github.com/yourname/payment-aggregator/go-service/internal/kafka"
)

func main() {
	count := flag.Int("count", 5, "Number of payments")
	interval := flag.Duration("interval", time.Second, "Interval between messages")
	flag.Parse()

	godotenv.Load()
	cfg := config.Load()

	producer, err := kafka.NewProducer(cfg)
	if err != nil {
		log.Fatal(err)
	}
	defer producer.Close()

	for i := 0; i < *count; i++ {
		payment := kafka.GenerateTestPayment()
		log.Printf("[SEND] %s | %s | %.2f %s",
			payment.ID, payment.Provider, payment.Amount, payment.Currency)
		producer.SendPayment(payment)
		time.Sleep(*interval)
	}

	producer.Flush(10000)
	log.Println("‚úÖ Done!")
}
```

---

## 11. Data Flow Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     COMPLETE DATA FLOW                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  Terminal 1: Producer                                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ  ‚îÇ $ go run cmd/producer/main.go -count=5  ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ                                         ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ [SEND] pay_abc | stripe | 50.00 usd     ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ [SEND] pay_def | razorpay | 1500 inr    ‚îÇ                    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                      ‚îÇ                                          ‚îÇ
‚îÇ                      ‚ñº                                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ  ‚îÇ              Kafka Topic                ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ            payments.raw                 ‚îÇ                    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                      ‚îÇ                                          ‚îÇ
‚îÇ                      ‚ñº                                          ‚îÇ
‚îÇ  Terminal 2: Server                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ  ‚îÇ $ go run cmd/server/main.go             ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ                                         ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ [CONSUMER] ‚úÖ pay_abc | STRIPE | 50.00  ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ [BROADCAST] Sent pay_abc to subscriber  ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ [CONSUMER] ‚úÖ pay_def | RAZORPAY | 1500 ‚îÇ                    ‚îÇ
‚îÇ  ‚îÇ [BROADCAST] Sent pay_def to subscriber  ‚îÇ                    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                      ‚îÇ                                          ‚îÇ
‚îÇ                      ‚îÇ gRPC Stream :50051                       ‚îÇ
‚îÇ                      ‚ñº                                          ‚îÇ
‚îÇ  Terminal 3: Node.js (next lesson)                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ  ‚îÇ [LOG] pay_abc | $50.00 USD | STRIPE     ‚îÇ  ‚Üê One at a time!  ‚îÇ
‚îÇ  ‚îÇ [LOG] pay_def | ‚Çπ1500 INR | RAZORPAY    ‚îÇ  ‚Üê One at a time!  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 12. Running Everything

### Step 1: Configure

```bash
cd go-service
cp .env.example .env
# Edit .env with your Kafka credentials
```

### Step 2: Install dependencies

```bash
go mod tidy
```

### Step 3: Start Server

```bash
# Terminal 1
go run cmd/server/main.go
```

### Step 4: Run Producer

```bash
# Terminal 2
go run cmd/producer/main.go -count=10 -interval=1s
```

### Step 5: Test with grpcurl (streaming)

```bash
# Terminal 3 - this will receive payments ONE AT A TIME!
grpcurl -plaintext localhost:50051 payment.PaymentService/StreamPayments
```

---

**Common questions:**
- "What happens if Node.js is slow to process?"
- "How do I handle consumer rebalancing?"
- "Can multiple Node.js instances subscribe?"